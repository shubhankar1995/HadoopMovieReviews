
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.ArrayWritable;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.io.Writable;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;

/**
 * 
 * @author Shubhankar Mathur
 * zId: z5229053
 * 
 * 
 * 
 * Course: COMP9313 Big Data Management
 * Title: Assignment-1 MapReduce
 * 
 * 
 * 
 * Explanation:
 * This assignment aims at developing a solution for the problem where there are many movie reviews 
 * and the analyst wants to group the users into the set of 2 movies and find the common users who 
 * reviewed the movie.
 * 
 * For the solution, I have used 2 jobs each containing 1 Mapper and 1 Reducer which execute one after 
 * the other. Input file is sent as an argument to the first job which produces an output file which 
 * acts as an input for the second job and output of the second job is the desired result.
 * 
 * The Mapper of the first job converts the data in the text file which was passed in the arguments which 
 * are separated by “::” into the key value pair. Users become the key and a writable object of movie and 
 * rating becomes the value.
 * 
 * The Reducer of the first job reduces the map created by the Mapper and creates an array of objects of 
 * movie and ratings where the key is the user and the array becomes the values. The output file is 
 * generated in the ‘out1’ sub-folder in the SequenceFileOutputFormat.
 * 
 * The Mapper of the second job reads the data generated by first Reducer and generates the movie pairs 
 * using the movie names present in the array and an object of user and rating of the first movie and 
 * the rating of the second movie. The movie pairs now become the key and the object becomes the values.
 * 
 * The Reducer of the second job reduces the map generated by the second Mapper by generating an array 
 * of the object of user and rating of the first movie and the rating of the second movie for the same 
 * movie pair. The output of this reducer gets generated in the “out2” sub-folder.
 * 
 * 
 */

public class AssigOnez5229053 {
	
	//******************************************************************************
	//	
	//	This class is used creating a writable array of MovieRatingWritable objects
	//	
	//******************************************************************************
	
	public static class MovieRatingArrayWritable extends ArrayWritable {

		//Default constructor
		public MovieRatingArrayWritable() {
			super(MovieRatingWritable.class);
		}
		
		//Constructor with fields to be able to store the data which is inputed as an array
	    public MovieRatingArrayWritable(MovieRatingWritable[] values) {
	        super(MovieRatingWritable.class, values);
	    }

	    //Used to get the values of the array
	    @Override
	    public MovieRatingWritable[] get() {
	    	Writable[] temp = super.get();		//get the values from the object
	        if (temp != null) {					
	            int n = temp.length;
	            MovieRatingWritable[] items = new MovieRatingWritable[n];	
	          //Iterating through the values to store the data into a new array variable
	            for (int i = 0; i < temp.length; i++) {
	                items[i] = (MovieRatingWritable)temp[i];
	            }
	            return items;
	        } else {
	            return null;
	        }   
	    }

	    //Overrides the inbuilt function so that we can customized the output string
	    @Override
	    public String toString() {
	    	String out = "[";
	    	MovieRatingWritable[] values = get();		//gets the values
	    	int i = 0;
	        for (MovieRatingWritable a :values) {		//iterates through the object to get values
	        	out +=  a;
	        	if (values.length != i) {				//check to prevent adding a ',' after the last element
	        		out += ",";
	        	}
	        }
	        out += "]";
	        return out;
	    }
	}
	
	//******************************************************************************
	//	
	//	This class is used creating a writable array of UserRatingWritable objects
	//	
	//******************************************************************************

	public static class UserRatingArrayWritable extends ArrayWritable {

		//Default constructor
		public UserRatingArrayWritable() {
			super(UserRatingWritable.class);
		}
		
		//Constructor with fields to be able to store the data which is inputed as an array
	    public UserRatingArrayWritable(UserRatingWritable[] values) {
	        super(UserRatingWritable.class, values);
	    }

	  //Used to get the values of the array
	    @Override
	    public UserRatingWritable[] get() {
	    	Writable[] temp = super.get();			//get the values from the object
	        if (temp != null) {
	            int n = temp.length;
	            UserRatingWritable[] items = new UserRatingWritable[n];
	          //Iterating through the values to store the data into a new array variable
	            for (int i = 0; i < temp.length; i++) {
	                items[i] = (UserRatingWritable)temp[i];
	            }
	            return items;
	        } else {
	            return null;
	        }   
	    }

	  //Overrides the inbuilt function so that we can customized the output string
	    @Override
	    public String toString() {
	    	String out = "[";
	    	UserRatingWritable[] values = get();		//gets the values
	    	int i = 0;
	        for (UserRatingWritable a :values) {		//iterates through the object to get values
	        	out +=  a;
	        	i++;
	        	if (values.length != i) {				//check to prevent adding a ',' after the last element
	        		out += ",";
	        	}
	        }
	        out += "]";
	        return out;
	    }
	}

	//************************************************************************************
	//	
	//	This class is used creating a objects which stores the Movie name and the rating
	//	
	//************************************************************************************
	public static class MovieRatingWritable implements Writable {
		private Text movie;
		private IntWritable rating;
		
		//Default constructor
		public MovieRatingWritable() {
			this.movie = new Text(" ");
			this.rating = new IntWritable(-1);
		}
		
		//Constructor with fields to be able to store the data which is inputed
		public MovieRatingWritable(Text movie, IntWritable rating) {
			super();
			this.movie = movie;
			this.rating = rating;
		}

		//get the movie value
		public Text getMovie() {
			return movie;
		}

		//assign the movie value
		public void setMovie(Text movie) {
			this.movie = movie;
		}

		//get the rating value
		public IntWritable getRating() {
			return rating;
		}

		//set the rating value
		public void setRating(IntWritable rating) {
			this.rating = rating;
		}

		//read the fields in the object
		@Override
		public void readFields(DataInput data) throws IOException {
			this.movie.readFields(data);
			this.rating.readFields(data);
			
		}

		//write the data into the object
		@Override
		public void write(DataOutput data) throws IOException {
			this.movie.write(data);
			this.rating.write(data);
			
		}
		
		 //Overrides the inbuilt function so that we can customized the output string
		@Override
		public String toString() {
			return "(" + this.movie.toString() + "," + this.rating.toString() + ")";
		}
		
	}
	
	//************************************************************************************
	//	
	//	This class is used creating a objects which stores the Movie name and the rating
	//	
	//************************************************************************************
	public static class UserRatingWritable implements Writable {

		private Text user;
		private IntWritable rating1;
		private IntWritable rating2;
		
		//Default constructor
		public UserRatingWritable() {
			this.user = new Text(" ");
			this.rating1 = new IntWritable(-1);
			this.rating2 = new IntWritable(-1);
		}
		
		//Constructor with fields to be able to store the data which is inputed
		public UserRatingWritable(Text user, IntWritable rating1, IntWritable rating2) {
			super();
			this.user = user;
			this.rating1 = rating1;
			this.rating2 = rating2;
		}

		//get the user value
		public Text getUser() {
			return user;
		}

		//set the user value
		public void setUser(Text user) {
			this.user = user;
		}

		//get the first movie's rating value
		public IntWritable getRating1() {
			return rating1;
		}

		//set the first movie's rating value
		public void setRating1(IntWritable rating1) {
			this.rating1 = rating1;
		}

		//get the second movie rating value
		public IntWritable getRating2() {
			return rating2;
		}

		//set the second movie's rating value
		public void setRating2(IntWritable rating2) {
			this.rating2 = rating2;
		}

		//read the fields in the object
		@Override
		public void readFields(DataInput data) throws IOException {
			this.user.readFields(data);
			this.rating1.readFields(data);
			this.rating2.readFields(data);
		}

		//write the data into the object
		@Override
		public void write(DataOutput data) throws IOException {
			this.user.write(data);
			this.rating1.write(data);
			this.rating2.write(data);
		}
		
		//Overrides the inbuilt function so that we can customized the output string
		@Override
		public String toString() {
			return "(" + this.user + "," + this.rating1 + "," + this.rating2 + ")";
		}
	}
	
	//************************************************************************************
	//	
	//	This class acts as a mapper of the first Job 
	//  Input key is of LongWitable type and the value is in Text type
	//	Output key is of Text type and the value is in MovieRatingWritable object type
	//	
	//************************************************************************************
	public static class MyMapper extends Mapper<LongWritable, Text, Text, MovieRatingWritable>{

		@Override
		protected void map(LongWritable key, Text value,
				Mapper<LongWritable, Text, Text, MovieRatingWritable>.Context context)
				throws IOException, InterruptedException {
			
			String [] parts = value.toString().split("::");			// input data is split using the delimiter
			MovieRatingWritable movie = new MovieRatingWritable();	// create the MovieRatingWritable object
			movie.setMovie(new Text(parts[1]));
			movie.setRating(new IntWritable(Integer.parseInt(parts[2])));
			context.write(new Text(parts[0]), movie );				// Write the key and value pair in the context
		}
		
	}
	
	//************************************************************************************
	//	
	//	This class acts as a Reducer of the first Job 
	//  Input key is of Text type and the value is in MovieRatingWritable type
	//	Output key is of Text type and the value is in MovieRatingArrayWritable type
	//	
	//************************************************************************************
	public static class MyReducer extends Reducer<Text, MovieRatingWritable, Text, MovieRatingArrayWritable> {

		@Override
		protected void reduce(Text key, Iterable<MovieRatingWritable> values,
				Reducer<Text, MovieRatingWritable, Text, MovieRatingArrayWritable>.Context context)
				throws IOException, InterruptedException {
			int i = 0;
			ArrayList<MovieRatingWritable> valuesTmp = new ArrayList<MovieRatingWritable>();
			for (MovieRatingWritable a : values) {				//values are stored in a temp ArrayList to be used later
				i++;											// find the count of the iterator
				MovieRatingWritable tmp = new MovieRatingWritable();
				tmp.setMovie(new Text(a.getMovie()));
				tmp.setRating(new IntWritable(a.getRating().get()));
				valuesTmp.add(tmp);
			}
			
			MovieRatingWritable[] tmp = new MovieRatingWritable[i];
			int j = 0;
			for (MovieRatingWritable a : valuesTmp) {		//create the arrayWritable object
				tmp[j] = new MovieRatingWritable();
				tmp[j].setMovie(new Text(a.getMovie()));
				tmp[j].setRating(new IntWritable(a.getRating().get()));
				j++;
			}
			context.write(new Text(key), new MovieRatingArrayWritable(tmp));	// Write the key and value pair in the context
		}
		
	}
	
	//************************************************************************************
	//	
	//	This class acts as a mapper of the second Job 
	//  Input key is of Text type and the value is in MovieRatingArrayWritable type
	//	Output key is of Text type and the value is in UserRatingWritable object type
	//	
	//************************************************************************************
	public static class MyMapper2 extends Mapper<Text, MovieRatingArrayWritable, Text, UserRatingWritable>{

		@Override
		protected void map(Text key, MovieRatingArrayWritable value,
				Mapper<Text, MovieRatingArrayWritable, Text, UserRatingWritable>.Context context)
				throws IOException, InterruptedException {
			MovieRatingWritable[] tmp1 = value.get();		//store the values of the arrayWritable
			MovieRatingWritable[] tmp2 = value.get();
			for (MovieRatingWritable a : tmp1) {			//generate the movie pair
				for (MovieRatingWritable b : tmp2) {
					if ((a.getMovie().toString().compareTo(b.getMovie().toString())) < 0 ) {
						UserRatingWritable usr = new UserRatingWritable();
						usr.setUser(new Text(key));
						usr.setRating1(new IntWritable(a.getRating().get()));
						usr.setRating2(new IntWritable(b.getRating().get()));
						context.write(new Text("(" + a.getMovie() + "," + b.getMovie() + ")"), usr); // Write the key and value pair in the context
					}
				}
			}
		}
	}
	
	//************************************************************************************
	//	
	//	This class acts as a Reducer of the second Job 
	//  Input key is of Text type and the value is in UserRatingWritable object type
	//	Output key is of Text type and the value is in UserRatingArrayWritable type
	//	
	//************************************************************************************
	public static class MyReducer2 extends Reducer<Text, UserRatingWritable, Text, UserRatingArrayWritable> {

		@Override
		protected void reduce(Text key, Iterable<UserRatingWritable> values,
				Reducer<Text, UserRatingWritable, Text, UserRatingArrayWritable>.Context context)
				throws IOException, InterruptedException {
			int i = 0;
			ArrayList<UserRatingWritable> valuesTmp = new ArrayList<UserRatingWritable>();
			for (UserRatingWritable a : values) {						//values are stored in a temp ArrayList to be used later
				i++;													// find the count of the iterator
				UserRatingWritable tmp = new UserRatingWritable();
				tmp.setUser(new Text(a.getUser()));
				tmp.setRating1(new IntWritable(a.getRating1().get()));
				tmp.setRating2(new IntWritable(a.getRating2().get()));
				valuesTmp.add(tmp);
			}
			
			UserRatingWritable[] tmp = new UserRatingWritable[i];
			int j = 0;
			for (UserRatingWritable a : valuesTmp) {						//create the arrayWritable object
				tmp[j] = new UserRatingWritable();
				tmp[j].setUser(new Text(a.getUser()));
				tmp[j].setRating1(new IntWritable(a.getRating1().get()));
				tmp[j].setRating2(new IntWritable(a.getRating2().get()));
				j++;
			}
			context.write(new Text(key), new UserRatingArrayWritable(tmp));	// Write the key and value pair in the context
		}
	}

	public static void main(String[] args) throws Exception {
		
		Configuration conf = new Configuration();
		Job job1 = Job.getInstance(conf, "assigOneJob1");    //Created the first Job
		
		job1.setJarByClass(AssigOnez5229053.class);
		
		job1.setMapperClass(MyMapper.class);
		job1.setReducerClass(MyReducer.class);
		
		job1.setOutputKeyClass(Text.class);
		job1.setOutputValueClass(MovieRatingArrayWritable.class);
		
		job1.setMapOutputKeyClass(Text.class);
		job1.setMapOutputValueClass(MovieRatingWritable.class);
		
		job1.setInputFormatClass(TextInputFormat.class);
		job1.setOutputFormatClass(SequenceFileOutputFormat.class);
		FileInputFormat.addInputPath(job1, new Path(args[0]));				//input path for the first job
		FileOutputFormat.setOutputPath(job1, new Path(args[1], "out1"));	//output path for the first job
		
		job1.waitForCompletion(true);										//wait for completion of first job
		if (!job1.waitForCompletion(true)) {
		      System.exit(1);
		}

		Job job2 = Job.getInstance(conf, "assigOneJob2");				//create second job
		
		job2.setJarByClass(AssigOnez5229053.class);
		
		job2.setMapperClass(MyMapper2.class);
		job2.setReducerClass(MyReducer2.class);
		
		job2.setOutputKeyClass(Text.class);
		job2.setOutputValueClass(UserRatingArrayWritable.class);
		
		job2.setMapOutputKeyClass(Text.class);
		job2.setMapOutputValueClass(UserRatingWritable.class);
		
		job2.setInputFormatClass(SequenceFileInputFormat.class);
		FileInputFormat.addInputPath(job2, new Path(args[1], "out1"));		//input path for the second job
		FileOutputFormat.setOutputPath(job2, new Path(args[1], "out2"));	//output path for the second job
		
		if (!job2.waitForCompletion(true)) {							//wait for the completion of the second job
		      System.exit(1);
		}
		
	}

}
